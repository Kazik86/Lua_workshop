Nazwy zastrzeżone w skryptach: Class, Derives, Script, _G

				     ***

W funkcjach OnInit i OnRestart nie działają wywołania wirtualne tzn.
foo() będzie szukało funkcji 'foo' w górę hierarchii ale począwszy od modułu,
w którym jest zadeklarowana aktualnie przetwarzana funkcja OnInit lub 
OnRestart.
Funkcje inne niż OnInit i OnRestart szukają funkcji począwszy od głównego modułu 
Aktora (czyli klasy stojącej najniżej w hierarchii dziedziczenia)

				     ***

Przy wywoływaniu metody z klasy bazowej trzeba pamiętać o tym, że dostęp do 
atrybutów, podobnie jak wywołania funkcji, jest wirtualny. Tzn. mając dwie 
klasy:

    -- A.lua

    Class = "A"

    function OnInit(me)
	me.foo = 1
    end

    function onlyInA(me)
	_G.print(me.foo)
    end

    -- B.lua

    Class = "B"
    Derives = "A.lua"

    function OnInit(me)
	me.foo = 2
    end

gdy ze skryptu B.lua wywołamy 'onlyInA' to na wyjściu dostaniemy 2. Jest to 
sprzeczne z doświadczeniem wyniesionym z choćby C++ ale konieczne aby 
poprawnie działały wirtualne wywołania funkcji. Przyczyną tego jest fakt, że 
do 'onlyInA' wysyłam całą tablicę 'Me', a należałoby tylko część "przyciętą" 
zgodnie z tym, które miejsce w hierarchii dziedziczenia zajmuje klasa "A". 
Niestety wówczas, gdyby z ciała 'onlyInA' zaszła potrzeba wywołania 
wirtualnego (czyli powrotu do klasy B) to tam również trafiłaby ta okrojona 
wersja (nieposiadająca atrybutów używanych w "B"). W razie gdyby był to 
problem można zmienić nazwy zmiennych (w klasie bazowej lub pochodnej) 
albo w klasie "A" użyć zmiennej 'foo' precyzyjnie określając, że chodzi nam 
o 'foo' z klasy "A": me.A.foo = 1

				     ***

TODO:

Zbiór wszystkich gadżetów Aktora zdefiniowany jest jako std::list<eGadget*>. 
Elementy do tej listy dodawane są w eGadget::create. To nie jest optymalne 
rozwiązanie bo wymga wielu operacji 'new'. Mógłbym to zrobic ładniej 
i zastapic std::list przez std::vector z prealokowanym miejscem na gadżety 
(metoda 'reserve' w std::vector). W tym celu muszę uprzednio znać liczbe 
gadżetów. Wcześniej miałem to zaimplementowane tak:

void eActor::createGadgetsContainer(lua_State* aLua)
{
    std::vector<eGadget*>::size_type gadgetsNum = 0;

    // najpierw policzmy ile aktor ma gadżetów
    for (int ref : iMeRef) {
	lua_rawgeti(aLua, LUA_REGISTRYINDEX, ref);
	lua_pushnil(aLua);

	while (lua_next(aLua, -2) != 0) {
	    if (lua_isuserdata(aLua, -1) && !lua_islightuserdata(aLua, -1))
		++gadgetsNum;

	    lua_pop(aLua, 1);
	}

	lua_pop(aLua, 1);
    }

    // miejsce na gadżety
    iGadgets.reserve(gadgetsNum);

    // a teraz tworzymy listę gadżetów
    auto itBeg = iMeRef.crbegin();
    auto itEnd = iMeRef.crend();

    for (auto it = itBeg; it != itEnd; ++it) {
	lua_rawgeti(aLua, LUA_REGISTRYINDEX, *it);
	lua_pushnil(aLua);

	while (lua_next(aLua, -2) != 0) {
	    if (lua_isuserdata(aLua, -1) && !lua_islightuserdata(aLua, -1))
		iGadgets.push_back(static_cast<eGadget*>(lua_touserdata(aLua, -1)));

	    lua_pop(aLua, 1);
	}

	lua_pop(aLua, 1);
    }
}

czyli najpierw iterowałem po 'me table' i zliczałem wszystkie 'userdata', 
potem alokacja miejsca za pomoca std::vector::reserve i znów iteracja 
i wrzucanie gadżetów do juz przygotowanego kontenera. Nie było to dobre bo:
- 'lua_next' za pomocą której iteruje zwraca elementy w innej kolejności niż 
  są zdefiniowane w skyryptowym 'OnInit', a co za tym idzie nie mam kontroli 
  nad kolejnościa update'u gadżetów;
- zliczanie gadżetów czyli te dwie iteracje są wykonywane dla _każdego_ 
  aktora, a przecież ilość gadżetów mogłaby być liczona tylko dla pierwszego 
  aktora danej klasy, zapamiętana w strukturze modułu i użyta dla kolejnych 
  aktorów tej klasy. Ale to nie rozwiązuje problemu kolejności update'u 
  gadżetów.

Trzeba by to rozwiązać dodając ekstra tablice postaci:

Class = "Foo"
Derives = ...
Gadgets = { _G.gFoo,
            { class = _G.gBar, name = "gadzetBar", args = { ... }}}

'_G.gFoo' oznacza tablicę w której znajduje się funkcja 'create' do stworzenia 
gadżetu o nazwie takiej jak gadżet, czyli "gFoo". Jeśli zajdzie potrzeba 
stworzenia gadżetu o innej nazwie lub sparametryzowania go to użyjemy zapisu 
jak w przypadku drugiego elementu tablicy 'Gadgets', a więc tablicy. I tu 
pojawia się problem bo zarówno surowe '_G.gFoo' jak i tablica reprezentująca 
gadżet 'gBar' są właśnie tablicami, przy czym tablica 'gBar' nie zawiera 
funkcji 'create'. Wobec tego trzeba spr. czy w tablicy jest pole 'create', 
jeśli jest to znaczy że chcemy stworzyć gadżet o defaultowej nazwie. Jeśli nie 
ma, to spr. czy obecne jest pole 'class', i opcjonalnie 'name' lub 'args' 
(w zależności od tego czego nam potrzeba).
Wprowadzenie dodatkowej tablicy dostarcza nam informacji o ilości gadżetów dla 
aktorów tej klasy. Ilość elementów w tej tablicy z poziomu C++ mogę dostać 
z 'lua_len'. Następnie poiterować z użyciem 'lua_gettable':

    for (int i = 1; i <= table_size; ++i) {
	lua_pushnumber(lua, i);
	lua_gettable(lua, -2)
	// spr. czy jest to tablica z 'create' czy z 'class'
	// odpalić 'create'
	// ...
    }

Oczywiście referencję i rozmiar tablicy 'Gadgets' trzeba zapisać w strukturze 
opisującej moduł danej klasy.

				     ***

W manualu (rozdział 3.7 Table constructors) znalazłem ciekawy fragment:

    Lua also offers a special syntax to initialize a table record-like, as in 
    the next example:
    a = {x=10, y=20}
    This previous line is equivalent to these commands:
    a = {}; a.x=10; a.y=20
    The original expression, however, is faster, because Lua creates the table 
    already with the right size.

Zatem używając 'table constructors' mżna by przyspieszyc proces tworzenia 'me 
table' dla każdego aktora. Zamiast dotychczasowego:

    function Init(me)
	me.foo = 1
	me.bar = 2
    end

można dodać ekstra funkcję w rodzaju:

    function SetProps()
	return { foo = 1,
		 bar = 2 }
    end
				     ***

Pewnie kiedyś będę potrzebował w skrypcie czegoś w rodzaju 'sleep' czy 
'yield'. Chyba mozna by to zrealizować przy użyciu 'continuations'.

				     ***

Mechanizm wysyłania przez gadżety eventów. Coś w stylu 'send 
animationFinished', aby mozna było to obsłużyć z poziomu skryptu. Kod, który 
ma zostać wywołany pm stronie skrypu w odpowiedzi na dany event może mieć 
postać funkcji przypisanej do propertisu gadżetu np.

    function Init(me)
	me.gAnim = _G.gAnim.create(me)
	me.gFoo.onAnimFinished = onAnimFinished
    end

    function onAnimFinished()
	...
    end

albo nawet funkcji anonimowej:

    function Init(me)
	me.gAnim = _G.gAnim.create(me)
	me.gFoo.onAnimFinished = function()
				    ...
				 end
    end

				     ***

Mechanizm walidacji skryptów. Obecnie muszę odpalić cały silnik, żeby 
dowiedzieć się że coś jest nie tak. Trzeba dodać jakiś argument wiersza 
polecenia, który odpali tylko kod spr. poprawnośc skryptu i wyrzuci output 
w jakimś standardowym formacie, żeby mozna było to ładnie wyświetlić 
w edytorze. Chyba najprościej będzie napisac jakiś parser w Lua bo łatwo 
zintegruję to z reszta silnika, który już używa Luy do skryptowania.

				     ***

Jak kiedyś się dorobię systemu automatycznej dokumentacji gadżetów to trzeba 
by przerobić makra dające dostęp do atrybutów, tak aby mogła być zczytywana 
również domyślna wartość każdego z atrybutów.

				     ***

w eTextureMgr::getTexture używam std::cerr. Zamiast tego powinien być logger.

				     ***

W userdata.h mam: inline void pushVal(lua_State* aLua, std::string aVal). Jest 
to słabe (przekazanie stringa przez wartość). Do smth z tym dziadostwem.

				     ***

W klasie 'eFsm' tam gdzie sprawdzam, czy 'shift' nie został wywołany z 'leave' 
trzeba wypisać jakis warning. W tym celu potrzebna klasa Logger np. z trzema 
typami outputu: msg, warning i error.

				     ***

obecnie mam pojedynczą, globalną listę modułów. W przypadku gdy będę chciał 
załadować ten sam moduł do kilku stanów Lua będzie problem, bo funkcja 'load' 
zwróci mi moduł o zadanej nazwie ale pochodzący z innego stanu Luy - nie 
utworzy kolejnego. Ale może nie będzie to potrzebne. W takim wypadku trzeba by 
wyjebać atrybut lua_State* z definicji modułu i machnąć jakiś globalny do 
namespace'a.

				     ***

'replaceEnv' zmienia _ENV _każdej_ wywoływanej funkcji. Może by tu 
zapodać jakąś optymalizację bo nie jest to konieczne. _ENV powinno sie zmieniać 
tylko tym funkcjom, które odnalezione zostały wyżej w hierarchii (czyli dzieki 
metatablicom). Czyli cos w rodzaju:
    lua_rawget(lua, "nazwaFunkcji");
    if (lua_isnil(lua, -1)) // funkcji nie ma w głównym module, szukamy wyżej
        lua_pop(lua, 1)
	lua_getfield(lua, "nazwaFunkcji");
	// i tutaj kod ustawiający _ENV

Tylko czy to na pewno opłacalne? Przy odpowiednio częstym szukaniu wyżej 
w hierarchii zysk bedzie dyskusyjny, bo lua_getfield() ponownie przeszukuje 
główny moduł (szukało tam juz lua_rawget).

				     ***

Atrybuty aktora zapisywane są w kilku tablicach połączonych metatablicami, 
zgodnie z hierarchią dziedziczenia modułu Aktora:
    A -> B -> C
    A.foo != B.foo
    A.B.foo == B.foo

Celem takiej architektury było odtworzenie funkcjonalności przełączania _ENV 
dla funkcji ale tym razem na poziomie atrybutów. Czyli: wywołując funkcje 
z klasy bazowej z parametrem 'me' miało nastąpić "przycięcie" tej tablicy do 
poziomu hierarchii tej klasy, aby używane w ciele funkcji identyfikatory 
szukane były od poziomu tablicy 'me' odpowiadającej poziomowi klasy bazowej w górę, 
z pominięciem tablicy, której poziom odpowiada poziomowi klasy pochodnej. 
Niestety nie znalazłem prostego sposobu na implementację tego. Tzn. 
identyfikatory będę szukane we wszystkich tablicach, włącznie z tablicą klasy 
pochodnej, co daje efekt taki jak wywołanie funkcji wirtualnej ale na poziomie 
atrybutów:

    -- A.lua
    function OnInit(me)
	me.foo = 1
    end

    function bar(me)
	foo(me)
    end

    -- B.lua
    function OnInit(me)
	me.foo = 2
    end

    function foo(me)
	me.foo = 3 -- NADPISANY będzie 'foo' z 'A', nie z 'B' !!!
    end

Na razie nie wiem czy jest to zachowanie szkodliwe, czy może wręcz przeciwnie, 
przez przypadek udało się osiągnąć coś bardzo pozytecznego. Jesli będzie to 
nieprzydatne to może by uprościć architekture i zastapic ją pojedynczą 
tablicą, bez żadnych metatablic. Tzn. 'foo' będzie tylko jedno, dla całej 
hierarchii klas.

				     ***

W DEFINE_USERDATA_CLASS i DEFINE_GADGET_CLASS, w metodzie 'luaOpen' do 
rejestracji funkcji używam 'luaL_newlib'. Ta funkcja to w istocie makro, które 
w swoim wnętrzu wykorzystuje operator sizeof. Dzięki temu od razu tworzona jest 
tablica o potrzebnym rozmiarze (w przeciwieństwie do 'lua_newtable', która 
powiększa się dynamicznie). W przypadku dużej ilości gadżetów oznacza to duży 
przyrost wydajności.

Niestety płaci się za to wysoką cenę: tablica w której listujemy api musi być 
znana przed defnicją funkcji 'luaOpen'. To wymusza posługiwanie się makrami 
a nie szablonem. Rozwiązaniem może być zapanowanie nad momentem generowania 
funkcji z szablonu przy użyciu 'explicit instantition' dla szablonów. Ono 
jednak z kolei wiąże się z zaśmiecaniem kodu deklaracjami 'extern' w każdym 
przypadku użycia funkcji szablonowej.

				     ***

Przy tworzeniu hierarchii modułow i "meTablic" wykorzystuję schemat:

tablicaC -> metatablica[__index] -> tablicaB -> metatablica[__index] -> tablicaA

Metatablica jest tylko "wskaźnikiem" na tablicę klasy bazowej. Czy nie mozna 
by tego zastąpić czymś w rodzaju:

tablicaC -> tablicaB[__index] -> tablicaA

tzn. 'tablicaB' zawiera wszystkie swoje dane ale jednocześnie jest metatablicą 
dla 'tablicaA'. Analogicznie 'tablicaA' jest metatablicą dla 'tablicaB'.

W chuj wydajniejsze by to było.
