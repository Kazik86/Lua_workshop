Nazwy zastrzeżone w skryptach: Class, Derives, Script, _G

				     ***

W funkcjach OnInit i OnRestart nie działają wywołania wirtualne tzn.
foo() będzie szukało funkcji 'foo' w górę hierarchii ale począwszy od modułu,
w którym jest zadeklarowana aktualnie przetwarzana funkcja OnInit lub 
OnRestart.
Funkcje inne niż OnInit i OnRestart szukają funkcji począwszy od głównego modułu 
Aktora (czyli klasy stojącej najniżej w hierarchii dziedziczenia)

				     ***

Przy wywoływaniu metody z klasy bazowej trzeba pamiętać o tym, że dostęp do 
atrybutów, podobnie jak wywołania funkcji, jest wirtualny. Tzn. mając dwie 
klasy:

    -- A.lua

    Class = "A"

    function OnInit(me)
	me.foo = 1
    end

    function onlyInA(me)
	_G.print(me.foo)
    end

    -- B.lua

    Class = "B"
    Derives = "A.lua"

    function OnInit(me)
	me.foo = 2
    end

gdy ze skryptu B.lua wywołamy 'onlyInA' to na wyjściu dostaniemy 2. Jest to 
sprzeczne z doświadczeniem wyniesionym z choćby C++ ale konieczne aby 
poprawnie działały wirtualne wywołania funkcji. Przyczyną tego jest fakt, że 
do 'onlyInA' wysyłam całą tablicę 'Me', a należałoby tylko część "przyciętą" 
zgodnie z tym, które miejsce w hierarchii dziedziczenia zajmuje klasa "A". 
Niestety wówczas, gdyby z ciała 'onlyInA' zaszła potrzeba wywołania 
wirtualnego (czyli powrotu do klasy B) to tam również trafiłaby ta okrojona 
wersja (nieposiadająca atrybutów używanych w "B"). W razie gdyby był to 
problem można zmienić nazwy zmiennych (w klasie bazowej lub pochodnej) 
albo w klasie "A" użyć zmiennej 'foo' precyzyjnie określając, że chodzi nam 
o 'foo' z klasy "A": me.A.foo = 1

				     ***

TODO:

w eTextureMgr::getTexture używam std::cerr. Zamiast tego powinien być logger.

				     ***

W userdata.h mam: inline void pushVal(lua_State* aLua, std::string aVal). Jest 
to słabe (przekazanie stringa przez wartość). Do smth z tym dziadostwem.

				     ***

W klasie 'eFsm' tam gdzie sprawdzam, czy 'shift' nie został wywołany z 'leave' 
trzeba wypisać jakis warning. W tym celu potrzebna klasa Logger np. z trzema 
typami outputu: msg, warning i error.

				     ***

obecnie mam pojedynczą, globalną listę modułów. W przypadku gdy będę chciał 
załadować ten sam moduł do kilku stanów Lua będzie problem, bo funkcja 'load' 
zwróci mi moduł o zadanej nazwie ale pochodzący z innego stanu Luy - nie 
utworzy kolejnego. Ale może nie będzie to potrzebne. W takim wypadku trzeba by 
wyjebać atrybut lua_State* z definicji modułu i machnąć jakiś globalny do 
namespace'a.

				     ***

'replaceEnv' zmienia _ENV _każdej_ wywoływanej funkcji. Może by tu 
zapodać jakąś optymalizację bo nie jest to konieczne. _ENV powinno sie zmieniać 
tylko tym funkcjom, które odnalezione zostały wyżej w hierarchii (czyli dzieki 
metatablicom). Czyli cos w rodzaju:
    lua_rawget(lua, "nazwaFunkcji");
    if (lua_isnil(lua, -1)) // funkcji nie ma w głównym module, szukamy wyżej
        lua_pop(lua, 1)
	lua_getfield(lua, "nazwaFunkcji");
	// i tutaj kod ustawiający _ENV

Tylko czy to na pewno opłacalne? Przy odpowiednio częstym szukaniu wyżej 
w hierarchii zysk bedzie dyskusyjny, bo lua_getfield() ponownie przeszukuje 
główny moduł (szukało tam juz lua_rawget).

				     ***

Atrybuty aktora zapisywane są w kilku tablicach połączonych metatablicami, 
zgodnie z hierarchią dziedziczenia modułu Aktora:
    A -> B -> C
    A.foo != B.foo
    A.B.foo == B.foo

Celem takiej architektury było odtworzenie funkcjonalności przełączania _ENV 
dla funkcji ale tym razem na poziomie atrybutów. Czyli: wywołując funkcje 
z klasy bazowej z parametrem 'me' miało nastąpić "przycięcie" tej tablicy do 
poziomu hierarchii tej klasy, aby używane w ciele funkcji identyfikatory 
szukane były od poziomu tablicy 'me' odpowiadającej poziomowi klasy bazowej w górę, 
z pominięciem tablicy, której poziom odpowiada poziomowi klasy pochodnej. 
Niestety nie znalazłem prostego sposobu na implementację tego. Tzn. 
identyfikatory będę szukane we wszystkich tablicach, włącznie z tablicą klasy 
pochodnej, co daje efekt taki jak wywołanie funkcji wirtualnej ale na poziomie 
atrybutów:

    -- A.lua
    function OnInit(me)
	me.foo = 1
    end

    function bar(me)
	foo(me)
    end

    -- B.lua
    function OnInit(me)
	me.foo = 2
    end

    function foo(me)
	me.foo = 3 -- NADPISANY będzie 'foo' z 'A', nie z 'B' !!!
    end

Na razie nie wiem czy jest to zachowanie szkodliwe, czy może wręcz przeciwnie, 
przez przypadek udało się osiągnąć coś bardzo pozytecznego. Jesli będzie to 
nieprzydatne to może by uprościć architekture i zastapic ją pojedynczą 
tablicą, bez żadnych metatablic. Tzn. 'foo' będzie tylko jedno, dla całej 
hierarchii klas.

				     ***

W DEFINE_USERDATA_CLASS i DEFINE_GADGET_CLASS, w metodzie 'luaOpen' do 
rejestracji funkcji używam 'luaL_newlib'. Ta funkcja to w istocie makro, które 
w swoim wnętrzu wykorzystuje operator sizeof. Dzięki temu od razu tworzona jest 
tablica o potrzebnym rozmiarze (w przeciwieństwie do 'lua_newtable', która 
powiększa się dynamicznie). W przypadku dużej ilości gadżetów oznacza to duży 
przyrost wydajności.

Niestety płaci się za to wysoką cenę: tablica w której listujemy api musi być 
znana przed defnicją funkcji 'luaOpen'. To wymusza posługiwanie się makrami 
a nie szablonem. Rozwiązaniem może być zapanowanie nad momentem generowania 
funkcji z szablonu przy użyciu 'explicit instantition' dla szablonów. Ono 
jednak z kolei wiąże się z zaśmiecaniem kodu deklaracjami 'extern' w każdym 
przypadku użycia funkcji szablonowej.

				     ***

Przy tworzeniu hierarchii modułow i "meTablic" wykorzystuję schemat:

tablicaC -> metatablica[__index] -> tablicaB -> metatablica[__index] -> tablicaA

Metatablica jest tylko "wskaźnikiem" na tablicę klasy bazowej. Czy nie mozna 
by tego zastąpić czymś w rodzaju:

tablicaC -> tablicaB[__index] -> tablicaA

tzn. 'tablicaB' zawiera wszystkie swoje dane ale jednocześnie jest metatablicą 
dla 'tablicaA'. Analogicznie 'tablicaA' jest metatablicą dla 'tablicaB'.

W chuj wydajniejsze by to było.
